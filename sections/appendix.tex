\section{Amplifier Offset Correction}
\label{sec:ampoffset}
The amplifier offset (amp-offset) correction runs as part of the instrument signature removal (ISR) process.
This correction is designed to address systematic discontinuities in background sky levels across amplifier boundaries.
It is believed that these discontinuities arise from electronic biases between adjacent amplifiers, persisting even after the application of dark and flat corrections.

Drawing on the \texttt{PanSTARRS} Pattern Continuity algorithm \citep{2020ApJS..251....4W}, our method aims to eliminate these offsets, thereby preventing problems such as background over-/under-subtraction at amplifier boundaries caused by discontinuities across the detector.

The amp-offset algorithm initially computes a robust flux difference measure between two narrow strips on opposite sides of each amplifier-amplifier interface.
Regions containing detected sources, or pixel data which have been masked for other reasons, are not considered.
These amp-interface differences are stored in an amp-offset matrix; diagonal entries represent the number of neighboring amplifiers, and off-diagonal entries encode information about the associations between amplifiers.
A complementary interface matrix encodes directional information for these associations.
Using this information, a least-squares minimization is performed to determine the optimal pedestal value to be added or subtracted to each amp which would reduce the amp-offset between that amplifier and all of its neighboring amplifiers.
This method is generalized to support 2D amplifier geometries within a detector, as with LSSTCam, incorporating length-based weighting into the matrices to account for amplifiers that are not square.

\section{Pipeline Configuration}
\label{sec:appendix_config}

An example of a pipeline configuration can be seen in the following code block which shows a fragment used to configure one of the shape measurement routines.
This abstraction is critical for maintainability, allowing the underlying file formats and or execution systems to evolve without impacting the pipeline code.
It also provides a mechanism to deprecate configuration settings which will change in future versions of the software stack, allowing users an easy migration path.

\begin{minipage}{\columnwidth}
    \begin{lstlisting}[caption=Code configuration in python, language=python]
import os.path
from lsst.utils import getPackageDir

try:
    location = getPackageDir("meas_extensions_shapeHSM")
except LookupError as e:
    print(f"Cannot enable shapeHSM ({e})")
else:
    path = os.path.join(location, "config", "enable.py")
    config.load(path)
    plugins = config.plugins
    plugin = plugins["ext_shapeHSM_HsmShapeRegauss"]
    plugin.deblendNChild = "deblend_nChild"
    # Enable debiased moments
    config.plugins.names |= ["ext_shapeHSM_HsmPsfMomentsDebiased"]
    \end{lstlisting}
\end{minipage}

The design of \texttt{pex\_config} centers around the concepts of \texttt{Field} and \texttt{Config} objects.
Fields represent individual configurable values -- things like exposure times, image quality thresholds, or database connection strings.
Each Field is strongly typed, supporting a variety of data types such as integers, floats, strings, booleans, and lists.
Config objects, on the other hand, are containers that group related Fields together, creating logical units of configuration.
One of the highlights of \texttt{pex\_config} is its composability.
Config objects can be nested within other Config objects using a special \texttt{ConfigField}, allowing for the creation of complex, hierarchical configuration trees that mirror the structure of the pipelines themselves.
This allows for modularity and reuse of configuration components across different parts of the system.

A strength of \texttt{pex\_config} is its flexible application of configuration values.
Values can be set at multiple stages: via command-line arguments, loaded from configuration files, or defined directly within the pipeline code.
Importantly, these stages are applied progressively, with later stages overriding earlier ones.
This allows for a powerful combination of default settings, user-defined customizations, and dynamic adjustments.
Mechanisms also exist to apply values to all instances of a particular Config object within a tree, simplifying the management of shared parameters and ensuring consistency.


Beyond runtime configuration, \texttt{pex\_config} is deeply concerned with data provenance and reproducibility.
It provides mechanisms for persisting and restoring configuration values, allowing for complete tracking of pipeline parameters used in a particular data processing run.
Crucially, it also maintains a history of each Field's value, recording when and where it was set -- whether via the command line, a configuration file, or programmatically.
This detailed history is invaluable for debugging, auditing, and ensuring the reproducibility of scientific results.
The system also incorporates robust validation mechanisms, enabling checks on individual Fields and groups of values before they are used by the pipelines, preventing errors and ensuring data quality.
Validation can range from simple type checking, ensuring values fall within acceptable ranges or specific patters, to complex custom functions that enforce specific constraints.


Finally, \texttt{pex\_config} is designed with documentation in mind.
All Fields and Config objects can be richly documented using documentation strings and attributes.
This documentation structure is not only readable by humans but can also be parsed by automated tools to generate comprehensive documentation pages, eliminating the need for manual documentation creation.
This ensures that the configuration system is well-documented and easy to understand, even for new developers.
